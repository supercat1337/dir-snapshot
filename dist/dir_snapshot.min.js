import{createReadStream as N}from"node:fs";import{createHash as O}from"node:crypto";import{createReadStream as D}from"node:fs";var w=async s=>new Promise((a,r)=>{let n=O("sha256"),e=D(s);e.on("data",d=>n.update(d)),e.on("end",()=>a(n.digest("hex"))),e.on("error",r)});function $(s="snapshot",a="ndjson"){let r=new Date,n=r.getFullYear(),e=String(r.getMonth()+1).padStart(2,"0"),d=String(r.getDate()).padStart(2,"0"),h=String(r.getHours()).padStart(2,"0"),t=String(r.getMinutes()).padStart(2,"0"),o=String(r.getSeconds()).padStart(2,"0");return`${s}.${n}-${e}-${d}.${h}-${t}-${o}.${a}`}function f(s,a){return a.every(r=>r in s)}function g(s){return/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/.test(s)}import{createInterface as A}from"node:readline";async function y(s){let a=N(s,{encoding:"utf-8"}),r=A({input:a,crlfDelay:1/0}),n=!0,e=!1,d=!1,h=!1;try{for await(let t of r)if(n)if(P(t))n=!1,e=!0;else throw new Error(`Invalid header: ${t}`);else if(e){if(F(t)){e=!1,d=!0;let o=JSON.parse(t);if(o.status!=="success")throw console.warn(`Snapshot has status: ${o.status}, but should be "success"`),o.message&&console.warn(`Snapshot has message: ${o.message}`),new Error("Snapshot is invalid: "+t)}else if(!C(t))throw new Error(`Invalid footer or entry: ${t}`)}else if(d&&t!=="")throw new Error(`Unexpected data: ${t}`);h=!0}catch(t){console.error(t.message)}return r.close(),h}function P(s){let a=JSON.parse(s);return a.type==="dir-snapshot"&&g(a.createdAt)&&f(a,["version","type","createdAt","machineId","rootPath"])}function C(s){let a=JSON.parse(s);return f(a,["path","type","ctime","mtime","depth"])}function F(s){let a=JSON.parse(s);return f(a,["status"])}import{createWriteStream as J}from"node:fs";import{readdir as V,lstat as z}from"node:fs/promises";import{join as _,resolve as u}from"node:path";var m=class{constructor(a,r,n,e,d,h,t){this.path=a,this.type=r,this.size=h,this.ctime=n,this.mtime=e,this.sha256=t,this.depth=d}};async function H(s){let{outputFile:a,dirPath:r,excludePaths:n=[],maxDepth:e=1/0,machineId:d="unknown",metadata:h={}}=s,t=J(a,{flags:"w"}),o=u(r),i=!0,p={version:"1.0",type:"dir-snapshot",createdAt:new Date().toISOString(),machineId:d,rootPath:o.replace(/\\/g,"/"),...h};t.write(`${JSON.stringify(p)}
`);try{await E(o,t,n,e);let l=JSON.stringify({status:"success"});t.write(l)}catch(l){console.error("Error processing directory:",l);let v=JSON.stringify({status:"error",message:l.message});t.write(v),i=!1}return t.end(),i}async function E(s,a,r=[],n=1/0,e=0){if(x(u(s),r))return;let d=await V(s);for(let h of d){let t=_(s,h),o=u(t).replace(/\\/g,"/");if(x(o,r))continue;let i=await z(o),p=new m(o,i.isDirectory()?"directory":"file",i.ctime.toISOString(),i.mtime.toISOString(),e);i.isFile()&&(p.sha256=await w(o),p.size=i.size),a.write(`${JSON.stringify(p)}
`),i.isDirectory()&&e<n&&await E(o,a,r,n,e+1)}}function x(s,a){return a.some(r=>typeof r=="string"?u(r)===s:r instanceof RegExp?r.test(s):!1)}import{createReadStream as M}from"node:fs";import{createInterface as j}from"node:readline";async function I(s){let a=M(s,{encoding:"utf-8"}),r=j({input:a,crlfDelay:1/0}),n=null,e=new Map,d=null;for await(let h of r){let t=JSON.parse(h);t.rootPath?n=t:t.status?d=t:t.path&&e.set(t.path,t)}if(!n||!d)throw new Error("Invalid snapshot file format.");return{header:n,entries:e,footer:d}}import{existsSync as R}from"node:fs";var c=class{#r;#o=new Map;#a;#e=!1;#t;constructor(a){if(!R(a))throw new Error("Snapshot file does not exist.");this.#t=a}get path(){return this.#t}isOpened(){return this.#e}get header(){if(!this.#e)throw new Error("Snapshot is not opened.");return this.#r}get entries(){if(!this.#e)throw new Error("Snapshot is not opened.");return this.#o}get footer(){if(!this.#e)throw new Error("Snapshot is not opened.");return this.#a}async open(){if(this.isOpened())throw new Error("Cannot open snapshot again. Create a new instance of Snapshot instead.");let a=this.#t;if(!await y(a))throw new Error("Snapshot file is invalid.");try{let n=await I(a);return this.#r=n.header,this.#o=n.entries,this.#a=n.footer,this.#e=!0,!0}catch{return this.#e=!1,!1}}};var S=class{added=[];deleted=[];moved=[];metaDataChanged=[];contentChanged=[];period={start:"",end:""};toJSON(){return{period:this.period,added:this.added,metaDataChanged:this.metaDataChanged,contentChanged:this.contentChanged,moved:this.moved,deleted:this.deleted}}};async function b(s,a){let r=new c(s),n=new c(a);if(await Promise.all([r.open(),n.open()]),r.header.rootPath!==n.header.rootPath)throw new Error("Snapshots are not for the same directory: "+r.header.rootPath+" vs "+n.header.rootPath);if(r.header.createdAt===n.header.createdAt)throw new Error("Snapshots are the same: "+r.header.createdAt);let e=new S,d=r.header.createdAt<n.header.createdAt?r:n,h=r.header.createdAt<n.header.createdAt?n:r;e.period.start=d.header.createdAt,e.period.end=h.header.createdAt;for(let[t,o]of h.entries){let i=d.entries.get(t);if(i){if(o.type!==i.type){e.deleted.push(i),e.added.push(o);continue}if(o.type==="file"){if(o.sha256!==i.sha256){e.contentChanged.push({oldValue:i,newValue:o});continue}if(o.size!==i.size){e.contentChanged.push({oldValue:i,newValue:o});continue}}if(o.ctime!==i.ctime){e.metaDataChanged.push({oldValue:i,newValue:o});continue}if(o.mtime!==i.mtime){e.metaDataChanged.push({oldValue:i,newValue:o});continue}}else{e.added.push(o);continue}}for(let[t,o]of d.entries)h.entries.get(t)||e.deleted.push(o);for(let t=0;t<e.deleted.length;t++)for(let o=0;o<e.added.length;o++)e.deleted[t].type==="file"&&e.added[o].type==="file"&&e.deleted[t].size===e.added[o].size&&e.deleted[t].sha256===e.added[o].sha256&&(e.moved.push({src:e.deleted[t],dst:e.added[o]}),e.deleted.splice(t,1),e.added.splice(o,1),t--,o--);return e}export{c as Snapshot,b as compareSnapshots,H as createSnapshot,$ as generateSnapshotName,y as validateSnapshot};
